/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */

"use strict";

function peg$subclass(child, parent) {
  function ctor() { this.constructor = child; }
  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
}

function peg$SyntaxError(message, expected, found, location) {
  this.message  = message;
  this.expected = expected;
  this.found    = found;
  this.location = location;
  this.name     = "SyntaxError";

  if (typeof Error.captureStackTrace === "function") {
    Error.captureStackTrace(this, peg$SyntaxError);
  }
}

peg$subclass(peg$SyntaxError, Error);

peg$SyntaxError.buildMessage = function(expected, found) {
  var DESCRIBE_EXPECTATION_FNS = {
        literal: function(expectation) {
          return "\"" + literalEscape(expectation.text) + "\"";
        },

        "class": function(expectation) {
          var escapedParts = "",
              i;

          for (i = 0; i < expectation.parts.length; i++) {
            escapedParts += expectation.parts[i] instanceof Array
              ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
              : classEscape(expectation.parts[i]);
          }

          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        },

        any: function(expectation) {
          return "any character";
        },

        end: function(expectation) {
          return "end of input";
        },

        other: function(expectation) {
          return expectation.description;
        }
      };

  function hex(ch) {
    return ch.charCodeAt(0).toString(16).toUpperCase();
  }

  function literalEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/"/g,  '\\"')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function classEscape(s) {
    return s
      .replace(/\\/g, '\\\\')
      .replace(/\]/g, '\\]')
      .replace(/\^/g, '\\^')
      .replace(/-/g,  '\\-')
      .replace(/\0/g, '\\0')
      .replace(/\t/g, '\\t')
      .replace(/\n/g, '\\n')
      .replace(/\r/g, '\\r')
      .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
      .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
  }

  function describeExpectation(expectation) {
    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
  }

  function describeExpected(expected) {
    var descriptions = new Array(expected.length),
        i, j;

    for (i = 0; i < expected.length; i++) {
      descriptions[i] = describeExpectation(expected[i]);
    }

    descriptions.sort();

    if (descriptions.length > 0) {
      for (i = 1, j = 1; i < descriptions.length; i++) {
        if (descriptions[i - 1] !== descriptions[i]) {
          descriptions[j] = descriptions[i];
          j++;
        }
      }
      descriptions.length = j;
    }

    switch (descriptions.length) {
      case 1:
        return descriptions[0];

      case 2:
        return descriptions[0] + " or " + descriptions[1];

      default:
        return descriptions.slice(0, -1).join(", ")
          + ", or "
          + descriptions[descriptions.length - 1];
    }
  }

  function describeFound(found) {
    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
  }

  return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
};

function peg$parse(input, options) {
  options = options !== void 0 ? options : {};

  var peg$FAILED = {},

      peg$startRuleFunctions = { start: peg$parsestart },
      peg$startRuleFunction  = peg$parsestart,

      peg$c0 = " ",
      peg$c1 = peg$literalExpectation(" ", false),
      peg$c2 = "\u3000",
      peg$c3 = peg$literalExpectation("\u3000", false),
      peg$c4 = "\t",
      peg$c5 = peg$literalExpectation("\t", false),
      peg$c6 = function() {
      	return "";
          },
      peg$c7 = function(seg) {
      	const my = seg.map(x => x["my"]).join("");
      	const mlc = seg.map(x => x["mlc"]).join(" ");
      	const pron = seg.map(x => x["pron"]);

      	return {
      	    my: my,
      	    mlc: mlc,
      	    pron: pron
      	};
          },
      peg$c8 = peg$anyExpectation(),
      peg$c9 = "\u1023",
      peg$c10 = peg$literalExpectation("\u1023", false),
      peg$c11 = "\u1024",
      peg$c12 = peg$literalExpectation("\u1024", false),
      peg$c13 = "\u1025",
      peg$c14 = peg$literalExpectation("\u1025", false),
      peg$c15 = "\u1026\u1038",
      peg$c16 = peg$literalExpectation("\u1026\u1038", false),
      peg$c17 = "\u1026",
      peg$c18 = peg$literalExpectation("\u1026", false),
      peg$c19 = "\u1027\u100A\u1037\u103A",
      peg$c20 = peg$literalExpectation("\u1027\u100A\u1037\u103A", false),
      peg$c21 = "\u1027",
      peg$c22 = peg$literalExpectation("\u1027", false),
      peg$c23 = "\u1029",
      peg$c24 = peg$literalExpectation("\u1029", false),
      peg$c25 = "\u102A",
      peg$c26 = peg$literalExpectation("\u102A", false),
      peg$c27 = function(vowel) {
      	var pron = [];
      	var mlc = "";
      	
      	switch(vowel){
      	case "ဣ":{
      	    pron = ["ʔḭ"];
      	    mlc = "i.";
      	    break;
      	}
      	case "ဤ":{
      	    pron = ["ʔì"];
      	    mlc = "i";
      	    break;
      	}
      	case "ဥ":{
      	    pron = ["ʔu" + falling_tone];
      	    mlc = "u.";
      	    break;
      	}
      	case "ဦ":{
      	    pron = ["ʔu" + low_tone];
      	    mlc = "u";
      	    break;
      	}
      	case "ဦး":{
      	    pron = ["ʔu" + high_tone];
      	    mlc = "u";
      	    break;
      	}
      	case "ဧ":{
      	    pron = ["ʔe" + low_tone];
      	    mlc = "e";
      	    break;
      	}
      	case "ဧည့်":{
      	    pron = ["ʔe" + falling_tone];
      	    mlc = "eny.";
      	    break;
      	}
      	case "ဩ":{
      	    pron = ["ʔɔ́"];
      	    mlc = "au:";
      	    break;
      	}
      	case "ဪ":{
      	    pron = ["ʔɔ̀"];
      	    mlc = "au";
      	    break;
      	}
      	}

      	return {
      	    my: vowel,
      	    mlc: mlc,
      	    pron: pron
      	}
          },
      peg$c28 = /^[\u1040\u1041\u1042\u1043\u1044\u1045\u1046\u1047\u1048\u1049]/,
      peg$c29 = peg$classExpectation(["\u1040", "\u1041", "\u1042", "\u1043", "\u1044", "\u1045", "\u1046", "\u1047", "\u1048", "\u1049"], false, false),
      peg$c30 = function(num) {
      	var my = num.join("");
      	var mlc = "";
      	var pron = [];

      	mlc = num.map(x => digit_convert[x]).join("");

      	
      	while(1){
      	    {
      		var c = num.pop();
      		if(!c) break;

      		if(digit_convert[c] != 0) pron.push(digit_pron[digit_convert[c]]);
      	    }

      	    {
      		var c = num.pop();
      		if(!c) break;

      		switch(digit_convert[c]){
      		case 3: case 4: case 5: case 9:
      		    pron.push("zɛ̀");
      		    break;
      		default:
      		    pron.push("sʰɛ̀");
      		}
      		    
      		if(digit_convert[c] != 0) pron.push(digit_pron_weakened[digit_convert[c]]);		
      	    }

      	    {
      		var c = num.pop();
      		if(!c) break;

      		pron.push("jà");
      		if(digit_convert[c] != 0) pron.push(digit_pron_weakened[digit_convert[c]]);		
      	    }

      	    {
      		var c = num.pop();
      		if(!c) break;

      		switch(digit_convert[c]){
      		case 3: case 4: case 5: case 9:
      		    pron.push("da̰ʊɴ");
      		    break;
      		default:
      		    pron.push("tʰàʊɴ");
      		}

      		if(digit_convert[c] != 0) pron.push(digit_pron_weakened[digit_convert[c]]);		
      	    }

      	    {
      		var c = num.pop();
      		if(!c) break;

      		switch(digit_convert[c]){
      		case 3: case 4: case 5: case 9:
      		    pron.push("ðáʊɴ");
      		    break;
      		default:
      		    pron.push("θáʊɴ");
      		}
      		
      		if(digit_convert[c] != 0) pron.push(digit_pron_weakened[digit_convert[c]]);		
      	    }
      	    
      	    {
      		var c = num.pop();
      		if(!c) break;

      		switch(digit_convert[c]){
      		case 3: case 4: case 5: case 9:
      		    pron.push("ðéɪɴ");
      		    break;
      		default:
      		    pron.push("θéɪɴ");
      		}
      		
      		if(digit_convert[c] != 0) pron.push(digit_pron_weakened[digit_convert[c]]);		
      	    }
      	    
      	    {
      		var c = num.pop();
      		if(!c) break;

      		switch(digit_convert[c]){
      		case 3: case 4: case 5: case 9:
      		    pron.push("ðáɴ");
      		    break;
      		default:
      		    pron.push("θáɴ");
      		}

      		if(digit_convert[c] != 0) pron.push(digit_pron_weakened[digit_convert[c]]);		
      	    }
      	}


      	pron.reverse();
      	pron = pron.join(" ");
      	
      	

      	
      	return {
      	    my: my,
      	    mlc: mlc,
      	    pron: [[pron]]
      	}
          },
      peg$c31 = "\u104C",
      peg$c32 = peg$literalExpectation("\u104C", false),
      peg$c33 = "\u104D",
      peg$c34 = peg$literalExpectation("\u104D", false),
      peg$c35 = "\u104E\u1004\u103A\u1038",
      peg$c36 = peg$literalExpectation("\u104E\u1004\u103A\u1038", false),
      peg$c37 = "\u104F",
      peg$c38 = peg$literalExpectation("\u104F", false),
      peg$c39 = function(symbol) {
      	var pron = [];
      	var mlc = "";
      	
      	switch(symbol){
      	case "၌":{
      	    pron = ["n̥aiʔ"];
      	    mlc = "hnai.";
      	    break;
      	}
      	case "၍":{
      	    pron = ["jwé"];
      	    mlc = "rwe";
      	    break;
      	}
      	case "၏":{
      	    pron = ["ʔḭ"];
      	    mlc = "e";
      	    break;
      	}
      	case "၎င်း":{
      	    pron = ["la̰ ɡàuɴ"];
      	    mlc = "la. kaung";
      	    break;
      	}
      	}
      	
      	return {
      	    my: symbol,
      	    mlc: mlc,
      	    pron: pron
      	}
          },
      peg$c40 = /^[\u104A\u104B]/,
      peg$c41 = peg$classExpectation(["\u104A", "\u104B"], false, false),
      peg$c42 = function(onset, rhyme) {
      	var pron = [];

      	onset["pron"].forEach(x => {
      	    rhyme["pron"].forEach(y => {
      		pron.push(x+y);
      	    })
      	});	 

      	return {
      	    my: onset["my"] + rhyme["my"],
      	    mlc: onset["mlc"] + rhyme["mlc"],
      	    pron: pron
      	};
          },
      peg$c43 = function(vowel, fin_cons, tone) {
      	var pron = [];
      	var mlc = "";

      	if(fin_cons.length > 0){
      	    switch(vowel){
      	    case "": case "ာ": case "ါ":{
      		mlc = "a";
      		pron = [];
      		break;
      	    }
      	    case "ိ":{
      		mlc = "i";
      		pron = ["ei"];
      		break;
      	    }
      	    case "ု":{
      		mlc = "u";
      		pron = ["oʊ"];
      		break;
      	    }
      	    case "ေ":{
      		mlc = "e";
      		pron = [];
      		break;
      	    }
      	    case "ော": case "ေါ":{
      		mlc = "au";
      		pron = ["aʊ"];
      		break;
      	    }
      	    case "ို":{
      		mlc = "ui";
      		pron = ["ai"];
      		break;
      	    }
      	    }

      	    mlc += fin_cons.map(x => consonant_romanize[x[1]]).join("");

      	    switch(fin_cons[0][1]){

      	    case "က": case "ခ": case "ဂ": case "ဃ":{
      		if(vowel == "" || vowel == "ာ" || vowel == "ါ") pron = ["ɛ"+fin_stop];
      		else pron = pron.map(s => s+fin_stop);
      		break;
      	    }
      	    case "င":{
      		if(vowel == "" || vowel == "ာ" || vowel == "ါ") pron = ["i"+fin_nasal];
      		else pron = pron.map(s => s+fin_nasal);
      		
      		break;
      	    }
      	    case "စ": case "ဆ": case "ဇ": case "ဈ":{
      		if(vowel == "" || vowel == "ာ" || vowel == "ါ") pron = ["i"+fin_stop];
      		else pron = pron.map(s => s+fin_stop);

      		break;
      	    }
      	    case "ဉ":{
      		if(vowel == "" || vowel == "ာ" || vowel == "ါ") pron = ["i"+fin_nasal];
      		else pron = pron.map(s => s+fin_nasal);
      		
      		break;
      	    }
      	    case "ည":{
      		pron = ["i", "e", "ɛ"];
      		break;
      	    }
      		
      	    case "ဋ": case "ဌ": case "ဍ": case "ဎ": case "တ": case "ထ": case "ဒ": case "ဓ":{
      		if(vowel == "" || vowel == "ာ" || vowel == "ါ") pron = ["a"+fin_stop];
      		else if(vowel == "ေ") pron = ["i"+fin_stop];
      		else pron = pron.map(s => s+fin_stop);
      		break;
      	    }
      	    case "ဏ": case "န":{
      		if(vowel == "" || vowel == "ာ" || vowel == "ါ") pron = ["a"+fin_nasal];
      		else if(vowel == "ေ") pron = ["i"+fin_nasal];
      		else pron = pron.map(s => s+fin_nasal);
      		break;
      	    }

      	    case "ပ": case "ဖ": case "ဗ": case "ဘ":{
      		if(vowel == "" || vowel == "ာ" || vowel == "ါ") pron = ["a"+fin_stop];
      		else pron = pron.map(s => s+fin_stop);
      		break;
      	    }
      	    case "မ":{
      		if(vowel == "" || vowel == "ာ" || vowel == "ါ") pron = ["a"+fin_nasal];
      		else pron = pron.map(s => s+fin_nasal);
      		break;
      	    }

      	    case "ံ":{
      		if(vowel == "" || vowel == "ာ" || vowel == "ါ") pron = ["a"+fin_nasal];
      		else pron = pron.map(s => s+fin_nasal);
      		break;
      	    }

      	    case "ယ":{
      		if(vowel == "" || vowel == "ာ" || vowel == "ါ"){
      		    mlc = ["ai"];
      		    pron = ["ɛ"];
      		}
      		else if(vowel == "ိ") pron = ["i"];
      		else if(vowel == "ု") pron = ["u"];
      		else if(vowel == "ေ") pron = ["e"];
      		else if(vowel == "ော") pron = ["ɔ"];
      		else if(vowel == "ို") pron = ["o"];
      		break;
      	    }
      	    case "ရ":{
      		if(vowel == "" || vowel == "ာ" || vowel == "ါ") pron = ["a"+fin_nasal];
      		else if(vowel == "ေ") pron = ["e"];
      		else if(vowel == "ို") pron = ["o"];
      		else pron = pron.map(s => s+fin_nasal);

      		break;
      	    }
      	    case "လ": case "ဠ":{
      		if(vowel == "" || vowel == "ာ" || vowel == "ါ") pron = ["a"+fin_nasal];
      		else if(vowel == "ို") pron = ["o"];
      		else pron = pron.map(s => s+fin_nasal);
      		break;
      	    }	
      	    case "ဝ":{
      		if(vowel == "" || vowel == "ာ" || vowel == "ါ") pron = ["ɔ"];
      		break;
      	    }	
      	    case "သ":{

      		if(vowel == "" || vowel == "ာ" || vowel == "ါ") pron = ["a"+fin_nasal];
      		else if(vowel == "ေ") pron = ["i"+fin_stop, "e"];
      		else pron = pron.map(s => s+fin_nasal);
      		break;
      	    }	
      	    case "ဟ":{
      		if(vowel == "ို") pron = ["o"];
      		else pron = pron.map(s => s+fin_nasal);

      		break;
      	    }
      	    }

      	    if(tone == high_tone_my){
      		pron = pron.map(x => {
      		    if(x[x.length-1] != fin_stop){
      			return x[0] + high_tone + x.slice(1);
      		    }else{
      			return x;
      		    }
      		});

      		mlc += ":";
      	    }
      	    else if(tone == falling_tone_my || fin_cons[2]){
      		pron = pron.map(x => {
      		    if(x[x.length-1] != fin_stop){
      			return x[0] + falling_tone + x.slice(1);
      		    }else{
      			return x;
      		    }
      		});

      		mlc += ".";
      	    }else{
      		pron = pron.map(x => {
      		    if(x[x.length-1] != fin_stop){
      			return x[0] + low_tone + x.slice(1);
      		    }else{
      			return x;
      		    }
      		});	    
      	    }

      	    
      	}else{
      	    switch(vowel){
      	    case "":{
      		pron = ["a"+falling_tone];
      		mlc = "a.";
      		break;
      	    }
      	    case "ာ": case "ါ":{
      		pron = ["a"+low_tone];
      		mlc = "a";
      		if(tone == high_tone_my){
      		    pron = ["a"+high_tone];
      		    mlc = "a:";
      		}
      		break;
      	    }
      	    case "ိ":{
      		pron = ["i"+falling_tone]
      		mlc = "i.";
      		break;
      	    }
      	    case "ီ":{
      		pron = ["i"+low_tone];
      		mlc = "i";
      		if(tone == high_tone_my){
      		    pron = ["i"+high_tone];
      		    mlc = "i:";
      		}
      		break;
      	    }
      	    case "ု":{
      		pron = ["u"+falling_tone];
      		mlc = "u.";
      		break;
      	    }
      	    case "ူ":{
      		pron = ["u"+low_tone];
      		mlc = "u";
      		if(tone == high_tone_my){
      		    pron = ["u"+high_tone];
      		    mlc = "u:";
      		}
      		break;
      	    }
      	    case "ေ":{
      		pron = ["e"+low_tone];
      		mlc = "e";
      		if(tone == high_tone_my){
      		    pron = ["e"+high_tone];
      		    mlc = "e:";
      		}else if(tone == falling_tone){
      		    pron = ["e"+falling_tone];
      		    mlc = "e.";
      		}
      		break;
      	    }
      	    case "ဲ":{
      		pron = ["ɛ"+high_tone];
      		mlc = "ai:";
      		if(tone == falling_tone){
      		    pron = ["ɛ"+falling_tone];
      		    mlc = "ai.";
      		}
      		break;
      	    }
      	    case "ော": case "ေါ":{
      		pron = ["o"+high_tone];
      		mlc = "au:";
      		if(tone == falling_tone){
      		    pron = ["o"+falling_tone];
      		    mlc = "au.";
      		}
      		break;
      	    }
      	    case "ော်": case "ေါ်":{
      		pron = ["o"+low_tone];
      		mlc = "au";
      		break;
      	    }
      	    case "ို":{
      		pron = ["ɔ"+low_tone];
      		mlc = "ui";
      		if(tone == high_tone_my){
      		    pron = ["ɔ"+high_tone];
      		    mlc = "ui:";
      		}else if(tone == falling_tone){
      		    pron = ["ɔ"+falling_tone];
      		    mlc = "ui.";
      		}
      		break;
      	    }
      	    }

      	    pron.push("ə");
      	}

      	var my = (vowel||"") + (fin_cons?fin_cons.map(x => x[0]).join(""):"") + (tone||"");

      	return {
      	    my: my,
      	    mlc: mlc,
      	    pron: pron
      	}
          },
      peg$c44 = "\u1031\u102C\u103A",
      peg$c45 = peg$literalExpectation("\u1031\u102C\u103A", false),
      peg$c46 = "\u1031\u102B\u103A",
      peg$c47 = peg$literalExpectation("\u1031\u102B\u103A", false),
      peg$c48 = "\u102D\u102F",
      peg$c49 = peg$literalExpectation("\u102D\u102F", false),
      peg$c50 = "\u1031\u102C",
      peg$c51 = peg$literalExpectation("\u1031\u102C", false),
      peg$c52 = "\u1031\u102B",
      peg$c53 = peg$literalExpectation("\u1031\u102B", false),
      peg$c54 = "\u102C",
      peg$c55 = peg$literalExpectation("\u102C", false),
      peg$c56 = "\u102B",
      peg$c57 = peg$literalExpectation("\u102B", false),
      peg$c58 = "\u102D",
      peg$c59 = peg$literalExpectation("\u102D", false),
      peg$c60 = "\u102E",
      peg$c61 = peg$literalExpectation("\u102E", false),
      peg$c62 = "\u102F",
      peg$c63 = peg$literalExpectation("\u102F", false),
      peg$c64 = "\u1030",
      peg$c65 = peg$literalExpectation("\u1030", false),
      peg$c66 = "\u1031",
      peg$c67 = peg$literalExpectation("\u1031", false),
      peg$c68 = "\u1032",
      peg$c69 = peg$literalExpectation("\u1032", false),
      peg$c70 = "",
      peg$c71 = /^[\u1000\u1001\u1002\u1003\u1004\u1005\u1006\u1007\u1008\u1009\u100A\u100B\u100C\u100D\u100E\u100F\u1010\u1011\u1012\u1013\u1014\u1015\u1016\u1017\u1018\u1019\u101A\u101B\u101C\u101D\u101E\u101F\u1020\u1021]/,
      peg$c72 = peg$classExpectation(["\u1000", "\u1001", "\u1002", "\u1003", "\u1004", "\u1005", "\u1006", "\u1007", "\u1008", "\u1009", "\u100A", "\u100B", "\u100C", "\u100D", "\u100E", "\u100F", "\u1010", "\u1011", "\u1012", "\u1013", "\u1014", "\u1015", "\u1016", "\u1017", "\u1018", "\u1019", "\u101A", "\u101B", "\u101C", "\u101D", "\u101E", "\u101F", "\u1020", "\u1021"], false, false),
      peg$c73 = "\u103A",
      peg$c74 = peg$literalExpectation("\u103A", false),
      peg$c75 = "\u1039",
      peg$c76 = peg$literalExpectation("\u1039", false),
      peg$c77 = function(fin_cons, tone, con) {
      	return [(fin_cons||"")+(tone||"")+con.join(""), fin_cons, tone];
          },
      peg$c78 = "\u1036",
      peg$c79 = peg$literalExpectation("\u1036", false),
      peg$c80 = function(tone) {
      	return ['ံ'+(tone||""), 'ံ', tone];
          },
      peg$c81 = "\u1038",
      peg$c82 = peg$literalExpectation("\u1038", false),
      peg$c83 = "\u1037",
      peg$c84 = peg$literalExpectation("\u1037", false),
      peg$c85 = function(init_cons, medi_cons) {
      	var pron = [];
      	var mlc = "";

      	var my = init_cons;
      	if(medi_cons & has_medial_y) my += "ျ";
      	if(medi_cons & has_medial_r) my += "ြ";
      	if(medi_cons & has_medial_w) my += "ွ";
      	if(medi_cons & has_medial_h) my += "ှ";
      	
      	
      	switch(init_cons){
      	case "က":{
      	    pron = ["k", "g"];
      	    if((medi_cons & has_medial_y) || (medi_cons & has_medial_r)) pron = ["tɕ", "dʑ"];
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ခ":{
      	    pron = ["kʰ", "g"];
      	    if((medi_cons & has_medial_y) || (medi_cons & has_medial_r)) pron = ["tɕʰ", "dʑ"];
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ဂ":{
      	    pron = ["g"];
      	    if((medi_cons & has_medial_y) || (medi_cons & has_medial_r)) pron = ["dʑ"];
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ဃ":{
      	    pron = ["g"];
      	    break;
      	}
      	case "င":{
      	    pron = ["ŋ"];
      	    if((medi_cons & has_medial_y) || (medi_cons & has_medial_r)) pron = ["ɲ"];
      	    if(medi_cons & has_medial_h) pron = pron.map(s => s+"̊");
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "စ":{
      	    pron = ["s", "z"];
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ဆ":{
      	    pron = ["sʰ", "z"];
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ဇ":{
      	    pron = ["z"];
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ဈ":{
      	    pron = ["z"];
      	    break;
      	}
      	case "ဉ": case "ည":{
      	    pron = ["ɲ"];
      	    if(medi_cons & has_medial_h) pron = pron.map(s => s+"̊");
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ဋ":{
      	    pron = ["t", "d"];
      	    break;
      	}
      	case "ဌ":{
      	    pron = ["tʰ", "d"];
      	    break;
      	}
      	case "ဍ":{
      	    pron = ["d"];
      	    break;
      	}
      	case "ဎ":{
      	    pron = ["d"];
      	    break;
      	}
      	case "ဏ":{
      	    pron = ["n"];
      	    break;
      	}
      	case "တ":{
      	    pron = ["t", "d"];
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ထ":{
      	    pron = ["tʰ", "d"];
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ဒ":{
      	    pron = ["d"];
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ဓ":{
      	    pron = ["d"];
      	    break;
      	}
      	case "န":{
      	    pron = ["n"];
      	    if(medi_cons & has_medial_h) pron = pron.map(s => s+"̥");
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ပ":{
      	    pron = ["p", "b"];
      	    if((medi_cons & has_medial_y) || (medi_cons & has_medial_r)) pron = pron.map(s => s+"j");
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ဖ":{
      	    pron = ["pʰ", "b"];
      	    if((medi_cons & has_medial_y) || (medi_cons & has_medial_r)) pron = pron.map(s => s+"j");
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ဗ":{
      	    pron = ["b"];
      	    if((medi_cons & has_medial_y) || (medi_cons & has_medial_r)) pron = pron.map(s => s+"j");
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ဘ":{
      	    pron = ["b", "pʰ"];
      	    if((medi_cons & has_medial_y) || (medi_cons & has_medial_r)) pron = pron.map(s => s+"j");
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "မ":{
      	    pron = ["m"];
      	    if(medi_cons & has_medial_h) pron = pron.map(s => s+"̥");
      	    if((medi_cons & has_medial_y) || (medi_cons & has_medial_r)) pron = pron.map(s => s+"j");
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ယ":{
      	    pron = ["j"];
      	    if(medi_cons & has_medial_h) pron = ["ʃ"];
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ရ":{
      	    pron = ["j", "r"];
      	    if(medi_cons & has_medial_h) pron = ["ʃ"];
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "လ":{
      	    pron = ["l"];
      	    if(medi_cons & has_medial_h) pron = pron.map(s => s+"̥");
      	    if((medi_cons & has_medial_y) || (medi_cons & has_medial_r)) pron = pron.map(s => s+"j");
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ဝ":{
      	    pron = ["w"];
      	    if(medi_cons & has_medial_h) pron = ["ʍ"];
      	    break;
      	}
      	case "သ":{
      	    pron = ["θ", "ð"];
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    if((medi_cons & has_medial_y) & (medi_cons & has_medial_h)) pron = ["ʃ"];
      	    break;
      	}
      	case "ဟ":{
      	    pron = ["h"];
      	    if(medi_cons & has_medial_w) pron = pron.map(s => s+"w");
      	    break;
      	}
      	case "ဠ":{
      	    pron = ["l"];
      	    break;
      	}
      	case "အ":{
      	    pron = ["ʔ"];
      	    break;
      	}
      	}

      	mlc = consonant_romanize[init_cons];

      	if(medi_cons & has_medial_y) mlc += "y";
      	if(medi_cons & has_medial_r) mlc += "r";
      	if(medi_cons & has_medial_w) mlc += "w";
      	if(medi_cons & has_medial_h) mlc = "h" + mlc;
      	
      	return {
      	    my: my,
      	    mlc: mlc,
      	    pron: pron
      	}
          },
      peg$c86 = function(medi_y, medi_r, medi_w, medi_h) {
      	return (medi_y?1:0) + (medi_r?2:0) + (medi_w?4:0) + (medi_h?8:0);
          },
      peg$c87 = "\u103E",
      peg$c88 = peg$literalExpectation("\u103E", false),
      peg$c89 = "\u103D",
      peg$c90 = peg$literalExpectation("\u103D", false),
      peg$c91 = "\u103B",
      peg$c92 = peg$literalExpectation("\u103B", false),
      peg$c93 = "\u103C",
      peg$c94 = peg$literalExpectation("\u103C", false),

      peg$currPos          = 0,
      peg$savedPos         = 0,
      peg$posDetailsCache  = [{ line: 1, column: 1 }],
      peg$maxFailPos       = 0,
      peg$maxFailExpected  = [],
      peg$silentFails      = 0,

      peg$result;

  if ("startRule" in options) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
    }

    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }

  function text() {
    return input.substring(peg$savedPos, peg$currPos);
  }

  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }

  function expected(description, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildStructuredError(
      [peg$otherExpectation(description)],
      input.substring(peg$savedPos, peg$currPos),
      location
    );
  }

  function error(message, location) {
    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

    throw peg$buildSimpleError(message, location);
  }

  function peg$literalExpectation(text, ignoreCase) {
    return { type: "literal", text: text, ignoreCase: ignoreCase };
  }

  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
  }

  function peg$anyExpectation() {
    return { type: "any" };
  }

  function peg$endExpectation() {
    return { type: "end" };
  }

  function peg$otherExpectation(description) {
    return { type: "other", description: description };
  }

  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos], p;

    if (details) {
      return details;
    } else {
      p = pos - 1;
      while (!peg$posDetailsCache[p]) {
        p--;
      }

      details = peg$posDetailsCache[p];
      details = {
        line:   details.line,
        column: details.column
      };

      while (p < pos) {
        if (input.charCodeAt(p) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }

        p++;
      }

      peg$posDetailsCache[pos] = details;
      return details;
    }
  }

  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos),
        endPosDetails   = peg$computePosDetails(endPos);

    return {
      start: {
        offset: startPos,
        line:   startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line:   endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }

  function peg$fail(expected) {
    if (peg$currPos < peg$maxFailPos) { return; }

    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }

    peg$maxFailExpected.push(expected);
  }

  function peg$buildSimpleError(message, location) {
    return new peg$SyntaxError(message, null, null, location);
  }

  function peg$buildStructuredError(expected, found, location) {
    return new peg$SyntaxError(
      peg$SyntaxError.buildMessage(expected, found),
      expected,
      found,
      location
    );
  }

  function peg$parsestart() {
    var s0, s1;

    s0 = [];
    s1 = peg$parseburmese_segment();
    if (s1 === peg$FAILED) {
      s1 = peg$parseburmese_digit();
      if (s1 === peg$FAILED) {
        s1 = peg$parseburmese_sign();
        if (s1 === peg$FAILED) {
          s1 = peg$parsespace();
          if (s1 === peg$FAILED) {
            s1 = peg$parseother();
          }
        }
      }
    }
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      s1 = peg$parseburmese_segment();
      if (s1 === peg$FAILED) {
        s1 = peg$parseburmese_digit();
        if (s1 === peg$FAILED) {
          s1 = peg$parseburmese_sign();
          if (s1 === peg$FAILED) {
            s1 = peg$parsespace();
            if (s1 === peg$FAILED) {
              s1 = peg$parseother();
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsespace() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (input.charCodeAt(peg$currPos) === 32) {
      s2 = peg$c0;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c1); }
    }
    if (s2 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 12288) {
        s2 = peg$c2;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c3); }
      }
      if (s2 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 9) {
          s2 = peg$c4;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c5); }
        }
      }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (input.charCodeAt(peg$currPos) === 32) {
          s2 = peg$c0;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c1); }
        }
        if (s2 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 12288) {
            s2 = peg$c2;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c3); }
          }
          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 9) {
              s2 = peg$c4;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c5); }
            }
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c6();
    }
    s0 = s1;

    return s0;
  }

  function peg$parseburmese_segment() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parseburmese_syllable();
    if (s2 === peg$FAILED) {
      s2 = peg$parseburmese_indep_vowel();
      if (s2 === peg$FAILED) {
        s2 = peg$parseburmese_symbol();
      }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseburmese_syllable();
        if (s2 === peg$FAILED) {
          s2 = peg$parseburmese_indep_vowel();
          if (s2 === peg$FAILED) {
            s2 = peg$parseburmese_symbol();
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c7(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseother() {
    var s0;

    if (input.length > peg$currPos) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c8); }
    }

    return s0;
  }

  function peg$parseburmese_indep_vowel() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 4131) {
      s1 = peg$c9;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c10); }
    }
    if (s1 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 4132) {
        s1 = peg$c11;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c12); }
      }
      if (s1 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 4133) {
          s1 = peg$c13;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c14); }
        }
        if (s1 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c15) {
            s1 = peg$c15;
            peg$currPos += 2;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c16); }
          }
          if (s1 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 4134) {
              s1 = peg$c17;
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c18); }
            }
            if (s1 === peg$FAILED) {
              if (input.substr(peg$currPos, 4) === peg$c19) {
                s1 = peg$c19;
                peg$currPos += 4;
              } else {
                s1 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c20); }
              }
              if (s1 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 4135) {
                  s1 = peg$c21;
                  peg$currPos++;
                } else {
                  s1 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c22); }
                }
                if (s1 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 4137) {
                    s1 = peg$c23;
                    peg$currPos++;
                  } else {
                    s1 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c24); }
                  }
                  if (s1 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 4138) {
                      s1 = peg$c25;
                      peg$currPos++;
                    } else {
                      s1 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c26); }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c27(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseburmese_digit() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = [];
    if (peg$c28.test(input.charAt(peg$currPos))) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c29); }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c28.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c29); }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c30(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseburmese_symbol() {
    var s0, s1;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 4172) {
      s1 = peg$c31;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c32); }
    }
    if (s1 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 4173) {
        s1 = peg$c33;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c34); }
      }
      if (s1 === peg$FAILED) {
        if (input.substr(peg$currPos, 4) === peg$c35) {
          s1 = peg$c35;
          peg$currPos += 4;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c36); }
        }
        if (s1 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 4175) {
            s1 = peg$c37;
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c38); }
          }
        }
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c39(s1);
    }
    s0 = s1;

    return s0;
  }

  function peg$parseburmese_sign() {
    var s0;

    if (peg$c40.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c41); }
    }

    return s0;
  }

  function peg$parseburmese_syllable() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseonset();
    if (s1 !== peg$FAILED) {
      s2 = peg$parserhyme();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c42(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parserhyme() {
    var s0, s1, s2, s3;

    s0 = peg$currPos;
    s1 = peg$parsevowel();
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsefinal_consonant();
      if (s3 === peg$FAILED) {
        s3 = peg$parseanusvara();
      }
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsefinal_consonant();
        if (s3 === peg$FAILED) {
          s3 = peg$parseanusvara();
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parsehigh_tone_mark();
        if (s3 === peg$FAILED) {
          s3 = peg$parsefalling_tone_mark();
        }
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c43(s1, s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsevowel() {
    var s0;

    if (input.substr(peg$currPos, 3) === peg$c44) {
      s0 = peg$c44;
      peg$currPos += 3;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c45); }
    }
    if (s0 === peg$FAILED) {
      if (input.substr(peg$currPos, 3) === peg$c46) {
        s0 = peg$c46;
        peg$currPos += 3;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c47); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c48) {
          s0 = peg$c48;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c49); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c50) {
            s0 = peg$c50;
            peg$currPos += 2;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c51); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 2) === peg$c52) {
              s0 = peg$c52;
              peg$currPos += 2;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c53); }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 4140) {
                s0 = peg$c54;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c55); }
              }
              if (s0 === peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 4139) {
                  s0 = peg$c56;
                  peg$currPos++;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c57); }
                }
                if (s0 === peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 4141) {
                    s0 = peg$c58;
                    peg$currPos++;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c59); }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 4142) {
                      s0 = peg$c60;
                      peg$currPos++;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c61); }
                    }
                    if (s0 === peg$FAILED) {
                      if (input.charCodeAt(peg$currPos) === 4143) {
                        s0 = peg$c62;
                        peg$currPos++;
                      } else {
                        s0 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c63); }
                      }
                      if (s0 === peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 4144) {
                          s0 = peg$c64;
                          peg$currPos++;
                        } else {
                          s0 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c65); }
                        }
                        if (s0 === peg$FAILED) {
                          if (input.charCodeAt(peg$currPos) === 4145) {
                            s0 = peg$c66;
                            peg$currPos++;
                          } else {
                            s0 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c67); }
                          }
                          if (s0 === peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 4146) {
                              s0 = peg$c68;
                              peg$currPos++;
                            } else {
                              s0 = peg$FAILED;
                              if (peg$silentFails === 0) { peg$fail(peg$c69); }
                            }
                            if (s0 === peg$FAILED) {
                              s0 = peg$c70;
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }

    return s0;
  }

  function peg$parsefinal_consonant() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    if (peg$c71.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c72); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsefalling_tone_mark();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        if (input.charCodeAt(peg$currPos) === 4154) {
          s4 = peg$c73;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c74); }
        }
        if (s4 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 4153) {
            s4 = peg$c75;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c76); }
          }
        }
        if (s4 !== peg$FAILED) {
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (input.charCodeAt(peg$currPos) === 4154) {
              s4 = peg$c73;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c74); }
            }
            if (s4 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 4153) {
                s4 = peg$c75;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c76); }
              }
            }
          }
        } else {
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c77(s1, s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseanusvara() {
    var s0, s1, s2;

    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 4150) {
      s1 = peg$c78;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c79); }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsefalling_tone_mark();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c80(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsehigh_tone_mark() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 4152) {
      s0 = peg$c81;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c82); }
    }

    return s0;
  }

  function peg$parsefalling_tone_mark() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 4151) {
      s0 = peg$c83;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c84); }
    }

    return s0;
  }

  function peg$parseonset() {
    var s0, s1, s2;

    s0 = peg$currPos;
    s1 = peg$parseinitial_consonant();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsemedial_consonant();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c85(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parseinitial_consonant() {
    var s0;

    if (peg$c71.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c72); }
    }

    return s0;
  }

  function peg$parsemedial_consonant() {
    var s0, s1, s2, s3, s4;

    s0 = peg$currPos;
    s1 = peg$parsemedial_y();
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsemedial_r();
      if (s2 === peg$FAILED) {
        s2 = null;
      }
      if (s2 !== peg$FAILED) {
        s3 = peg$parsemedial_w();
        if (s3 === peg$FAILED) {
          s3 = null;
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parsemedial_h();
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c86(s1, s2, s3, s4);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }

    return s0;
  }

  function peg$parsemedial_h() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 4158) {
      s0 = peg$c87;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c88); }
    }

    return s0;
  }

  function peg$parsemedial_w() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 4157) {
      s0 = peg$c89;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c90); }
    }

    return s0;
  }

  function peg$parsemedial_y() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 4155) {
      s0 = peg$c91;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c92); }
    }

    return s0;
  }

  function peg$parsemedial_r() {
    var s0;

    if (input.charCodeAt(peg$currPos) === 4156) {
      s0 = peg$c93;
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) { peg$fail(peg$c94); }
    }

    return s0;
  }


      const has_medial_y = 1;
      const has_medial_r = 2;
      const has_medial_w = 4;
      const has_medial_h = 8;


      const fin_stop = "ʔ";
      const fin_nasal = "ɴ";

      const high_tone = "́";
      const low_tone = "̀";
      const falling_tone = "̰";

      const high_tone_my = "း";
      const falling_tone_my = "့"

      const consonant_romanize = {
  	"က": "k", "ခ": "hk", "ဂ": "g", "ဃ": "gh", "င": "ng",
  	"စ": "c", "ဆ": "hc", "ဇ": "j", "ဈ": "jh", "ဉ": "ny", "ည": "ny",
  	"ဋ": "t", "ဌ": "ht", "ဍ": "d", "ဎ": "dh", "ဏ": "n",
  	"တ": "t", "ထ": "ht", "ဒ": "d", "ဓ": "dh", "န": "n",
  	"ပ": "p", "ဖ": "hp", "ဗ": "b", "ဘ": "bh", "မ": "m",
  	"ယ": "y", "ရ": "r", "လ": "l", "ဝ": "w", "သ": "s",
  	"ဟ": "h", "ဠ": "l", "အ": "", "ံ": "m"
      };

      const digit_convert = {

  	"၀": 0, "၁": 1, "၂": 2, "၃": 3, "၄": 4, "၅": 5, "၆": 6, "၇": 7, "၈": 8, "၉": 9
      };

      const digit_pron = {
  	0: "θòʊɴɲa̰", 1: "tɪʔ", 2: "n̥ɪʔ", 3: "θóʊɴ", 4: "lé", 5: "ŋá", 6: "tɕʰaʊʔ", 7: "kʰʊ̀ɴ n̥ɪʔ", 8: "ʃɪʔ", 9: "kó"
      }

      const digit_pron_weakened = {
      	0: "θòʊɴɲa̰", 1: "tə", 2: "n̥ə", 3: "θóʊɴ", 4: "lé", 5: "ŋá", 6: "tɕʰaʊʔ", 7: "kʰʊ̀ɴ n̥ə", 8: "ʃɪʔ", 9: "kó"
      }


  peg$result = peg$startRuleFunction();

  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }

    throw peg$buildStructuredError(
      peg$maxFailExpected,
      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
      peg$maxFailPos < input.length
        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
    );
  }
}

module.exports = {
  SyntaxError: peg$SyntaxError,
  parse:       peg$parse
};
